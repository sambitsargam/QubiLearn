[
  {
    "id": "basic-token",
    "name": "Basic Token Contract",
    "description": "A simple token contract with basic transfer functionality",
    "language": "cpp",
    "code": "#include <qpi.h>\n\nclass BasicToken {\nprivate:\n    uint64_t totalSupply;\n    map<PublicKey, uint64_t> balances;\n    \npublic:\n    BasicToken(uint64_t _totalSupply) : totalSupply(_totalSupply) {\n        balances[getOrigin()] = _totalSupply;\n    }\n    \n    uint64_t balanceOf(const PublicKey& account) const {\n        auto it = balances.find(account);\n        return it != balances.end() ? it->second : 0;\n    }\n    \n    bool transfer(const PublicKey& to, uint64_t amount) {\n        PublicKey from = getOrigin();\n        \n        if (balances[from] < amount) {\n            return false;\n        }\n        \n        balances[from] -= amount;\n        balances[to] += amount;\n        \n        return true;\n    }\n    \n    uint64_t getTotalSupply() const {\n        return totalSupply;\n    }\n};\n\n// Export functions for Qubic runtime\nBASIC_TOKEN_EXPORT(BasicToken);"
  },
  {
    "id": "voting-system",
    "name": "Voting System",
    "description": "A decentralized voting system with proposal management",
    "language": "cpp",
    "code": "#include <qpi.h>\n\nstruct Proposal {\n    string title;\n    string description;\n    uint64_t deadline;\n    uint64_t yesVotes;\n    uint64_t noVotes;\n    bool active;\n    PublicKey creator;\n};\n\nclass VotingSystem {\nprivate:\n    vector<Proposal> proposals;\n    map<uint32_t, map<PublicKey, bool>> hasVoted;\n    \npublic:\n    uint32_t createProposal(const string& title, const string& description, uint64_t duration) {\n        Proposal proposal;\n        proposal.title = title;\n        proposal.description = description;\n        proposal.deadline = getCurrentTick() + duration;\n        proposal.yesVotes = 0;\n        proposal.noVotes = 0;\n        proposal.active = true;\n        proposal.creator = getOrigin();\n        \n        proposals.push_back(proposal);\n        return proposals.size() - 1;\n    }\n    \n    bool vote(uint32_t proposalId, bool support) {\n        if (proposalId >= proposals.size()) {\n            return false;\n        }\n        \n        Proposal& proposal = proposals[proposalId];\n        PublicKey voter = getOrigin();\n        \n        if (!proposal.active || getCurrentTick() > proposal.deadline || hasVoted[proposalId][voter]) {\n            return false;\n        }\n        \n        hasVoted[proposalId][voter] = true;\n        \n        if (support) {\n            proposal.yesVotes++;\n        } else {\n            proposal.noVotes++;\n        }\n        \n        return true;\n    }\n    \n    Proposal getProposal(uint32_t proposalId) const {\n        if (proposalId < proposals.size()) {\n            return proposals[proposalId];\n        }\n        return Proposal();\n    }\n    \n    uint32_t getProposalCount() const {\n        return proposals.size();\n    }\n};\n\nVOTING_SYSTEM_EXPORT(VotingSystem);"
  },
  {
    "id": "oracle-integration",
    "name": "Oracle Integration",
    "description": "Smart contract with external data feed integration",
    "language": "cpp",
    "code": "#include <qpi.h>\n\nstruct PriceData {\n    uint64_t price;\n    uint64_t timestamp;\n    bool valid;\n};\n\nclass PriceOracle {\nprivate:\n    map<string, PriceData> prices;\n    PublicKey oracleOperator;\n    \npublic:\n    PriceOracle(const PublicKey& _operator) : oracleOperator(_operator) {}\n    \n    bool updatePrice(const string& symbol, uint64_t price) {\n        if (getOrigin() != oracleOperator) {\n            return false;\n        }\n        \n        PriceData data;\n        data.price = price;\n        data.timestamp = getCurrentTick();\n        data.valid = true;\n        \n        prices[symbol] = data;\n        return true;\n    }\n    \n    PriceData getPrice(const string& symbol) const {\n        auto it = prices.find(symbol);\n        if (it != prices.end()) {\n            return it->second;\n        }\n        return PriceData{0, 0, false};\n    }\n    \n    bool isPriceValid(const string& symbol, uint64_t maxAge) const {\n        auto it = prices.find(symbol);\n        if (it != prices.end()) {\n            uint64_t age = getCurrentTick() - it->second.timestamp;\n            return it->second.valid && age <= maxAge;\n        }\n        return false;\n    }\n    \n    void setOracleOperator(const PublicKey& newOperator) {\n        if (getOrigin() == oracleOperator) {\n            oracleOperator = newOperator;\n        }\n    }\n};\n\nORACLE_EXPORT(PriceOracle);"
  },
  {
    "id": "nft-contract",
    "name": "NFT Collection Contract",
    "description": "A complete NFT collection with minting and trading capabilities",
    "language": "cpp",
    "code": "#include <qpi.h>\n\nstruct NFTMetadata {\n    string name;\n    string description;\n    string imageUrl;\n    map<string, string> attributes;\n};\n\nclass NFTCollection {\nprivate:\n    string collectionName;\n    string symbol;\n    uint64_t totalSupply;\n    uint64_t maxSupply;\n    map<uint64_t, PublicKey> owners;\n    map<uint64_t, NFTMetadata> metadata;\n    map<PublicKey, uint64_t> balances;\n    PublicKey contractOwner;\n    \npublic:\n    NFTCollection(const string& _name, const string& _symbol, uint64_t _maxSupply) \n        : collectionName(_name), symbol(_symbol), maxSupply(_maxSupply), totalSupply(0) {\n        contractOwner = getOrigin();\n    }\n    \n    bool mint(const PublicKey& to, const NFTMetadata& nftMetadata) {\n        if (getOrigin() != contractOwner || totalSupply >= maxSupply) {\n            return false;\n        }\n        \n        uint64_t tokenId = totalSupply + 1;\n        owners[tokenId] = to;\n        metadata[tokenId] = nftMetadata;\n        balances[to]++;\n        totalSupply++;\n        \n        return true;\n    }\n    \n    bool transfer(uint64_t tokenId, const PublicKey& to) {\n        PublicKey from = getOrigin();\n        \n        if (owners[tokenId] != from) {\n            return false;\n        }\n        \n        owners[tokenId] = to;\n        balances[from]--;\n        balances[to]++;\n        \n        return true;\n    }\n    \n    PublicKey ownerOf(uint64_t tokenId) const {\n        auto it = owners.find(tokenId);\n        return it != owners.end() ? it->second : PublicKey{};\n    }\n    \n    uint64_t balanceOf(const PublicKey& owner) const {\n        auto it = balances.find(owner);\n        return it != balances.end() ? it->second : 0;\n    }\n    \n    NFTMetadata getMetadata(uint64_t tokenId) const {\n        auto it = metadata.find(tokenId);\n        return it != metadata.end() ? it->second : NFTMetadata{};\n    }\n};\n\nNFT_EXPORT(NFTCollection);"
  },
  {
    "id": "staking-contract",
    "name": "Token Staking Contract",
    "description": "A staking contract with rewards and lock periods",
    "language": "cpp",
    "code": "#include <qpi.h>\n\nstruct StakeInfo {\n    uint64_t amount;\n    uint64_t startTime;\n    uint64_t lockPeriod;\n    uint64_t rewardRate;\n    bool active;\n};\n\nclass StakingContract {\nprivate:\n    map<PublicKey, vector<StakeInfo>> stakes;\n    uint64_t totalStaked;\n    uint64_t rewardPool;\n    uint64_t minStakeAmount;\n    uint64_t defaultLockPeriod;\n    uint64_t baseRewardRate;\n    \npublic:\n    StakingContract(uint64_t _minStake, uint64_t _lockPeriod, uint64_t _rewardRate) \n        : minStakeAmount(_minStake), defaultLockPeriod(_lockPeriod), baseRewardRate(_rewardRate), totalStaked(0), rewardPool(0) {}\n    \n    bool stake(uint64_t amount, uint64_t lockPeriod = 0) {\n        if (amount < minStakeAmount) {\n            return false;\n        }\n        \n        PublicKey staker = getOrigin();\n        uint64_t actualLockPeriod = lockPeriod > 0 ? lockPeriod : defaultLockPeriod;\n        uint64_t rewardRate = calculateRewardRate(actualLockPeriod);\n        \n        StakeInfo newStake;\n        newStake.amount = amount;\n        newStake.startTime = getCurrentTick();\n        newStake.lockPeriod = actualLockPeriod;\n        newStake.rewardRate = rewardRate;\n        newStake.active = true;\n        \n        stakes[staker].push_back(newStake);\n        totalStaked += amount;\n        \n        return true;\n    }\n    \n    bool unstake(uint32_t stakeIndex) {\n        PublicKey staker = getOrigin();\n        \n        if (stakeIndex >= stakes[staker].size() || !stakes[staker][stakeIndex].active) {\n            return false;\n        }\n        \n        StakeInfo& stakeInfo = stakes[staker][stakeIndex];\n        uint64_t currentTime = getCurrentTick();\n        \n        if (currentTime < stakeInfo.startTime + stakeInfo.lockPeriod) {\n            return false; // Still locked\n        }\n        \n        uint64_t reward = calculateReward(stakeInfo, currentTime);\n        uint64_t totalReturn = stakeInfo.amount + reward;\n        \n        stakeInfo.active = false;\n        totalStaked -= stakeInfo.amount;\n        \n        // Transfer tokens back to staker (simulated)\n        return true;\n    }\n    \n    uint64_t calculateReward(const StakeInfo& stake, uint64_t currentTime) const {\n        uint64_t stakingDuration = currentTime - stake.startTime;\n        return (stake.amount * stake.rewardRate * stakingDuration) / (100 * 365 * 24 * 60 * 60); // Annual rate\n    }\n    \n    uint64_t calculateRewardRate(uint64_t lockPeriod) const {\n        // Longer lock periods get higher rewards\n        if (lockPeriod >= 365 * 24 * 60 * 60) return baseRewardRate * 2; // 1 year+\n        if (lockPeriod >= 180 * 24 * 60 * 60) return baseRewardRate * 15 / 10; // 6 months+\n        if (lockPeriod >= 90 * 24 * 60 * 60) return baseRewardRate * 12 / 10; // 3 months+\n        return baseRewardRate;\n    }\n    \n    vector<StakeInfo> getStakes(const PublicKey& staker) const {\n        auto it = stakes.find(staker);\n        return it != stakes.end() ? it->second : vector<StakeInfo>();\n    }\n};\n\nSTAKING_EXPORT(StakingContract);"
  }
]